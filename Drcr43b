import pandas as pd
from tkinter import Tk, filedialog, simpledialog
from collections import deque
from datetime import datetime
import os

# -------------------- CONFIG -------------------- #
from datetime import datetime

# Ask user for cutoff date
cutoff_input = simpledialog.askstring("Cutoff Date", "Enter cutoff date (dd-mm-yyyy):", initialvalue="31-03-2025")
try:
    CUTOFF_DATE = pd.to_datetime(cutoff_input, dayfirst=True)
except Exception as e:
    messagebox.showerror("Invalid Date", f"Error parsing date: {e}")
    exit()


# -------------------- FILE SELECTION -------------------- #
Tk().withdraw()
file_path = filedialog.askopenfilename(title="Select Ledger Excel File", filetypes=[("Excel files", "*.xlsx *.xls")])
if not file_path:
    print("❌ No file selected.")
    exit()

# -------------------- FILE TYPE (Debtor/Creditor) -------------------- #
from tkinter import simpledialog, messagebox

# Dropdown selection for file type
file_type = simpledialog.askstring(
    "Select Type",
    "Enter 'Debtor' or 'Creditor':\n(Tip: Type 'D' or 'C')",
    initialvalue="Debtor"
)

if not file_type:
    print("❌ No input provided.")
    exit()

file_type = file_type.strip().lower()
if file_type.startswith("d"):
    file_type = "debtor"
elif file_type.startswith("c"):
    file_type = "creditor"
else:
    messagebox.showerror("Error", "Invalid input. Please type 'Debtor' or 'Creditor'.")
    exit()

if file_type not in ['debtor', 'creditor']:
    print("❌ Invalid entry. Please enter either 'Debtor' or 'Creditor'.")
    exit()

# -------------------- READ AND PARSE LEDGER -------------------- #
df = pd.read_excel(file_path, header=None)
records = []
current_party = None

for idx, row in df.iterrows():
    # Detect new party
    if str(row[0]).strip().lower().startswith("ledger:"):
        current_party = str(row[1]).strip() if pd.notna(row[1]) else "Unknown"
        continue

    if current_party:
        # Only consider rows with valid dates as transaction lines
        date = pd.to_datetime(row[0] or 0, errors='coerce')
        if pd.isna(date) or date < pd.Timestamp("2000-01-01"):
            continue  # skip rows without valid date
        try:
            debit = float(row[5]) if not pd.isna(row[5]) else 0  # Column F
            credit = float(row[6]) if not pd.isna(row[6]) else 0  # Column G
        except:
            continue
        records.append([current_party, date, debit, credit])

# Create dataframe
data = pd.DataFrame(records, columns=["Party", "Date", "Debit", "Credit"])
data = data.sort_values(by=["Party", "Date"])

# -------------------- FIFO AGING + LOG -------------------- #
from collections import deque

def calculate_aging_fifo(df, cutoff_date, file_type):
    aging_summary = []
    log_details = []

    for party, group in df.groupby("Party"):
        group = group.sort_values("Date")
        entries = deque()
        unmatched_payments = deque()
        advance_amount = 0

        for _, row in group.iterrows():
            if pd.isna(row["Date"]):
                continue

            if file_type == "creditor":
                # Credit = Bill, Debit = Payment

                if row["Debit"] > 0:
                    unmatched_payments.append({'date': row["Date"], 'amount': row["Debit"]})

                elif row["Credit"] > 0:
                    bill = {'date': row["Date"], 'amount': row["Credit"], 'matched': 0,
                            'party': party, 'original_date': row["Date"], 'matched_by': []}

                    amt = bill["amount"]

                    while amt > 0 and unmatched_payments:
                        payment = unmatched_payments[0]
                        available = payment["amount"]
                        to_match = min(amt, available)
                        bill["matched"] += to_match
                        payment["amount"] -= to_match
                        amt -= to_match
                        bill["matched_by"].append(payment["date"])
                        if payment["amount"] <= 0:
                            unmatched_payments.popleft()

                    if bill["matched"] < bill["amount"]:
                        entries.append(bill)

            else:
                # Debtor logic
                if row["Debit"] > 0:
                    entries.append({'date': row["Date"], 'amount': row["Debit"], 'matched': 0})
                elif row["Credit"] > 0:
                    amt = row["Credit"]
                    while amt > 0 and entries:
                        invoice = entries[0]
                        available = invoice["amount"] - invoice["matched"]
                        to_match = min(amt, available)
                        invoice["matched"] += to_match
                        amt -= to_match
                        if invoice["matched"] == invoice["amount"]:
                            entries.popleft()
                    if amt > 0:
                        advance_amount += amt
                        log_details.append({
                            "Party": party,
                            "Invoice Date": row["Date"],
                            "Invoice Amount": "",
                            "Matched Amount": "",
                            "Unpaid Amount": amt,
                            "Age (in days)": "",
                            "Aging Bucket": "",
                            "Remarks": "Advance from customer"
                        })

        # Track Advance to Supplier
        if file_type == "creditor":
            for payment in unmatched_payments:
                amt = payment["amount"]
                if amt > 0:
                    advance_amount += amt
                    log_details.append({
                        "Party": party,
                        "Invoice Date": payment["date"],
                        "Invoice Amount": "",
                        "Matched Amount": "",
                        "Unpaid Amount": amt,
                        "Age (in days)": "",
                        "Aging Bucket": "",
                        "Remarks": "Advance to supplier"
                    })

        # Aging buckets
        buckets = {"0-30": 0, "31-60": 0, "61-90": 0, ">90": 0}
        for entry in entries:
            unpaid = entry["amount"] - entry["matched"]
            if unpaid <= 0 or entry["date"] > cutoff_date:
                continue
            age = (cutoff_date - entry["date"]).days
            if age <= 30:
                bucket = "0-30"
            elif age <= 60:
                bucket = "31-60"
            elif age <= 90:
                bucket = "61-90"
            else:
                bucket = ">90"
            buckets[bucket] += unpaid

            log_details.append({
                "Party": party,
                "Invoice Date": entry["date"],
                "Invoice Amount": entry["amount"],
                "Matched Amount": entry["matched"],
                "Unpaid Amount": unpaid,
                "Age (in days)": age,
                "Aging Bucket": bucket,
                "Remarks": ""
            })

        # Summary row
        party_summary = {
            "Party": party,
            "Total Outstanding": sum(buckets.values()),
            **buckets
        }

        if file_type == "debtor":
            party_summary["Advance from Customer"] = advance_amount
        elif file_type == "creditor":
            party_summary["Advance to Supplier"] = advance_amount

        aging_summary.append(party_summary)

    # ------------------ 43B(h) Analysis ------------------ #
    forty_five_days_after_cutoff = cutoff_date + pd.Timedelta(days=45)
    section_43b_log = []
    section_43b_summary = {}

    if file_type == "creditor":
        for entry in entries:
            unpaid = entry["amount"] - entry["matched"]
            if unpaid <= 0 or entry["original_date"] > cutoff_date:
                continue

            bill_age = (cutoff_date - entry["original_date"]).days

            disallowable = False
            payment_within_45 = False

            if bill_age > 45:
                disallowable = True
            else:
                for payment_date in entry["matched_by"]:
                    if cutoff_date < payment_date <= forty_five_days_after_cutoff:
                        payment_within_45 = True
                        break
                if not payment_within_45:
                    disallowable = True

            status = "❌ Disallow" if disallowable else "✅ Allow"

            section_43b_log.append({
                "Party": entry["party"],
                "Invoice Date": entry["original_date"],
                "Invoice Amount": entry["amount"],
                "Matched Amount": entry["matched"],
                "Unpaid as on 31-Mar": unpaid,
                "Age on 31-Mar": bill_age,
                "Paid within 45 days?": "Yes" if payment_within_45 else "No",
                "43B(h) Status": status
            })

            if entry["party"] not in section_43b_summary:
                section_43b_summary[entry["party"]] = {"Total Disallowable": 0, "Total Allowable": 0}

            if disallowable:
                section_43b_summary[entry["party"]]["Total Disallowable"] += unpaid
            else:
                section_43b_summary[entry["party"]]["Total Allowable"] += unpaid

        df_43b_log = pd.DataFrame(section_43b_log)
        df_43b_summary = pd.DataFrame([
            {"Party": k, **v} for k, v in section_43b_summary.items()
        ])
    else:
        df_43b_log = pd.DataFrame()
        df_43b_summary = pd.DataFrame()

    return pd.DataFrame(aging_summary), pd.DataFrame(log_details), df_43b_log, df_43b_summary

    

# -------------------- RUN AND EXPORT -------------------- #
aging_df, log_df, df_43b_log, df_43b_summary = calculate_aging_fifo(data, CUTOFF_DATE, file_type)

output_path = os.path.splitext(file_path)[0] + f"_{file_type}_aging_report.xlsx"
with pd.ExcelWriter(output_path, engine="openpyxl") as writer:
    aging_df.to_excel(writer, sheet_name="Aging Summary", index=False)
    log_df.to_excel(writer, sheet_name="FIFO Log", index=False)

    if not df_43b_log.empty:
        df_43b_log.to_excel(writer, sheet_name="43B(h) Log", index=False)
    if not df_43b_summary.empty:
        df_43b_summary.to_excel(writer, sheet_name="43B(h) Summary", index=False)

print(f"✅ Aging Report + Log saved to:\n{output_path}")
